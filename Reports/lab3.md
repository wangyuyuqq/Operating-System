<h1 align = "center">操作系统lab3实验报告</h1>

<h3 align = "center">实验名称：缺页异常和页面置换 </h3>

<h4 align = "center">小组成员：王昱  孟启轩  王梓丞</h4>


## 一、实验目的
1. 了解虚拟内存的Page Fault异常处理实现
2. 了解页替换算法在操作系统中的实现
3. 学会如何使用多级页表，处理缺页异常（Page Fault），实现页面置换算法。
## 二、实验内容


#### 练习0：填写已有实验
本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。


### 练习1：理解基于FIFO的页面替换算法（思考题）
>描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？

为了回答这个问题，我们需要先捋清楚页面置换的具体流程是什么，然后这个问题的答案就显而易见了。
#### 页面置换具体流程：
当发生缺页错误时，系统会将错误信息传递给Page Fault传递给`kern/trap/trap.c`中的`exception_handler `进行分类并打印错误信息。这里的异常处理程序会把`Page Fault`分发给`kern/mm/vmm.c`的`do_pgfault()`函数并尝试进行页面置换。随后错误信息会传递给`do_pgfault`函数尝试进行页面置换。

当进入到`do_pgfault`中时，同时会传入相对应的参数如页面结构体`mm`和发生缺页异常的地址`addr`。随后通过`find_vma`以及`get_pte`等函数，找到发生缺页异常地址对应的`vma`结构体以及页表和页表项。此时若找不到对应的页表项则会重新创建，并将其全部置0，同时会在后续分配物理页面进行映射关系的建立。

根据查找到的页表项后，会出现两种情况：

1. 得到的页表项为0（无论他是新创建的还是本身存在），即该页从未被分配过物理地址。此时调用 `pgdir_alloc_page` 函数分配新的物理页，并且通过`page_insert`建立新的映射。其中分配物理页的过程会通过对`alloc_page`以及`swap_out`等函数，实现对页面的换出及换入。

2. 得到的页表项不为0，则该页存在分配过物理地址的情况，如果页表项不为 0，说明页面之前被换出过，需要调用 `swap_in` 函数从磁盘中读取页面内容，将其加载到内存中的物理页中。而在第二种情况中，先通过`swap_in`将页面内容读入并通过`page_insert`将虚拟地址和物理地址的映射关系写入到页表项中，最后通过`swap_map_swappable`以及不同的`swap_manager`结构体进行页面交换策略的选择和实现。

在整个过程中，`do_pgfault` 根据 `vma_struct` 的 `vm_flags` 设置相应的访问权限，确保页面在访问时具有正确的权限属性。
#### FIFO中具体函数：
- **do_pgfault()**  
  页面缺失处理的入口函数，在缺页异常发生时调用，负责检查和恢复页面映射关系。

- **find_vma()**  
  检查出错的虚拟地址是否属于合法的虚拟内存区域，即判断该地址是否在页表的合法范围内。

- **get_pte()**  
  获取给定虚拟地址的页表项，如果对应的页表项不存在，则分配一个新的页表项。

- **page_remove_pte()**  
  删除指定页表项的映射关系，用于释放旧的页表项以便重新建立新的映射。

- **pte_create()**  
  创建新的页表项，根据给定的物理页号和标志位设置页表项，完成映射关系的建立。

- **pgdir_alloc_page()**  
  为一个虚拟地址分配物理页，并调用page_insert建立虚拟地址到物理地址的映射。

- **alloc_page()**  
  分配一个空闲的物理页，供后续使用或换入数据。

- **swap_in()**  
  处理缺页时将页面从硬盘换入内存，并在页表中恢复该虚拟地址的映射。

- **swap_out()**  
  当内存不足时，将一个页面换出到硬盘上，为新的页面腾出空间。

- **swapfs_read()**  
  从硬盘的交换区中读取指定页面的数据，将其加载到内存的物理页中。

- **swapfs_write()**  
  将页面数据写入硬盘的交换区，用于在页面被换出时保存其内容。

- **page_insert()**  
  根据虚拟地址和物理页建立映射关系，并在页表中插入新页表项，完成虚拟地址到物理地址的映射。

- **swap_map_swappable()**  
  将换入的页面标记为可交换状态，并将其添加到页面置换队列中（如FIFO队列）。

- **swap_out_victim()**  
  使用页面置换算法选择一个页面作为换出目标，并返回该页面的信息以便进行换出。

- **free_page()**  
  释放一个页面，标记其为可重新分配的空闲页。

- **tlb_invalidate()**  
  刷新TLB，确保更新后的页表信息被正确加载，避免访问错误的页面映射。

- **list_add()**  
  在页面置换队列（如FIFO队列）中添加页面，用于将新的页面插入到队列中，方便页面置换时进行管理。
- **assert()**
  它用于检查分配的页面是否为NULL或其他关键错误。如果assert()条件不满足，将触发断言失败，并可能导致程序终止。

**注意**：swap in () 函数只在do_pgfault()中被调用，来处理缺页异常，其中的刷新TLB的操作是在之后的page_insert()中实现。而swap out ()函数随时可能会被调用，如换入页面时、空闲页分配时等，只要满足消极策略时机，就会被调用。



#### 练习2：深入理解不同分页模式的工作原理（思考题）
> get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
> - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
> - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？


##### 2.1 sv32，sv39，sv48的异同：

在 RISC-V 的 sv32、sv39 和 sv48 模式中，虚拟地址被划分为多个部分，用于索引不同层级的页表。不同的模式支持不同大小的虚拟地址空间，这导致了页表层级和每一层的索引位数不同。

- **sv32** 模式使用 32 位虚拟地址，共支持 4GB 的虚拟地址空间。这种模式下，页表只有 **两级**，每级使用 **10 位索引**。高 10 位用于一级页表（页目录）的索引，中间 10 位用于二级页表（页表）的索引，最后的 12 位用于页内偏移。

- **sv39** 模式使用 39 位虚拟地址，共支持 512GB 的虚拟地址空间。这种模式下，页表有 **三级**，每级使用 **9 位索引**。高 9 位用于顶层页表（PML4 页表）的索引，中间 9 位用于二级页表（页目录）的索引，接下来的 9 位用于一级页表（页表）的索引，最后的 12 位用于页内偏移。

- **sv48** 模式使用 48 位虚拟地址，共支持 256TB 的虚拟地址空间。这种模式下，页表有 **四级**，每级使用 **9 位索引**。高 9 位用于四级页表（PML5 页表）的索引，依次往下的 9 位分别用于三级、二级和一级页表的索引，最后的 12 位用于页内偏移。

这种结构使得 sv32、sv39 和 sv48 模式在寻址范围和页表层级上有所不同。sv39 和 sv48 由于每级都采用 9 位索引，在多级查找时每一层的处理逻辑非常相似，而 sv32 使用 10 位索引，仅有两级结构，因此其代码实现会略有不同。

在我们的ucore架构中使用的是`sv39`模式，页表分为了三个层级：PDX1、PDX0和PTX，如下所示：
```cpp {.line-numbers}
// +--------9-------+-------9--------+-------9--------+---------12----------+
// | Page Directory | Page Directory |   Page Table   | Offset within Page  |
// |     Index 1    |    Index 2     |                |                     |
// +----------------+----------------+----------------+---------------------+
//  \-- PDX1(la) --/ \-- PDX0(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
//  \-------------------PPN(la)----------------------/
```
get_pte()函数的逻辑是类似于一个两层递归向下寻找页表项的过程，根据PDX1和三级页表PDE找到二级页表PDE，再结合PDX0，找到一级页表PDE，根据PTX找到PTE。这种逐级索引的特性导致了这两段代码在结构上具有高度的相似性。

综上所述：这两段代码如此相近的原因就是因为它们都是依次按照多级页表的映射关系，找到下一级的页目录或者页表项，然后如果出现了不存在或者不有效的情况，就进行了重新分配。

如果是sv32则只需要进行一次pdep然后直接返回就可以得到页表项，这是因为其只有两层页表关系；而sv48则还需要多一层页表递进关系，因此需要pdep2,pdep1和pdep0然后才能返回。

##### 2.2 ：`get_pte()`将页表项将查找和分配合并的合理性

在 `get_pte()` 函数中，页表项的查找和分配被合并在一起执行。这种设计的优势和劣势如下：

1. **优点**  
   - 将查找和分配功能合并，使代码更为紧凑和高效。我们可以在层次递进映射依次取出每一级的页表或者页目录项时候就去查看一下其是否缺失，由此进行针对性的分配和弥补缺失。在处理页面缺失时，只需调用一个函数即可完成页表项的查找和必要的分配，减少了函数调用的次数。
   - 这种设计方式对 RISC-V 的分页机制（如 sv32、sv39、sv48 模式）较为适应，因为不同模式下页表项的操作逻辑相似，合并功能可以避免代码重复，便于维护和理解。

2. **缺点**  
   - 在实际应用中，很多情况下我们只需要查找页表项，而不需要进行分配。例如，当只需要检查某一页表项是否存在时，不希望额外进行页面分配操作。拆分查找和分配功能可以避免这种情况下的不必要内存消耗，提高代码复用性。
   - 将查找和分配分开后，每个函数将只负责一个任务，代码逻辑更清晰。这样也更方便单独测试和调试每个功能，提升代码的可维护性和易读性。分离功能的代码结构化管理可以帮助开发者更快速地定位和解决问题，增加代码的健壮性。

### 3.练习3：给未被映射的地址映射上物理页（需要编程）

补充完成 do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限的时候需要参考页

面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。

请在实验报告中简要说明你的设计实现过程。

#### 1.**设计实现过程**  

```cpp
if (*ptep == 0) {
        if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
            cprintf("pgdir_alloc_page in do_pgfault failed\n");
            goto failed;
        }
    } else {//如果页表项不为0，且交换空间初始化成功（swap_init_ok为真），则认为这是一个交换条目，
            //从磁盘加载数据到物理页面，并将物理页面映射到虚拟地址addr，然后将页面标记为可交换
        /*LAB3 EXERCISE 3: YOUR CODE
        * 请你根据以下信息提示，补充函数
        * 现在我们认为pte是一个交换条目，那我们应该从磁盘加载数据并放到带有phy addr的页面，
        * 并将phy addr与逻辑addr映射，触发交换管理器记录该页面的访问情况
        *
        *  一些有用的宏和定义，可能会对你接下来代码的编写产生帮助(显然是有帮助的)
        *  宏或函数:
        *    swap_in(mm, addr, &page) : 分配一个内存页，然后根据
        *    PTE中的swap条目的addr，找到磁盘页的地址，将磁盘页的内容读入这个内存页
        *    page_insert ： 建立一个Page的phy addr与线性addr la的映射
        *    swap_map_swappable ： 设置页面可交换
        */
        if (swap_init_ok) {
            struct Page *page = NULL;
            // 你要编写的内容在这里，请基于上文说明以及下文的英文注释完成代码编写
            //(1）According to the mm AND addr, try
            //to load the content of right disk page
            //into the memory which page managed.
            swap_in(mm,addr,&page);
            //(2) According to the mm,
            //addr AND page, setup the
            //map of phy addr <--->
            //logical addr
            page_insert(mm->pgdir,page,addr,perm);
            //(3) make the page swappable.
            swap_map_swappable(mm,addr,page,1);
            page->pra_vaddr = addr;
        } else {
            cprintf("no swap_init_ok but ptep is %x, failed\n", *ptep);
            goto failed;
        }
    }
```
在`do_pgfault`函数中，需要补充的部分主要处理的是当页表项（PTE）不为0，且存在交换空间时的情况。这意味着请求的页面可能已经被换出到磁盘上，现在需要将其换入（即加载回内存）。以下是补充部分的设计实现过程：

**检查交换空间初始化状态**：
   - 使用全局变量`swap_init_ok`来检查交换空间是否已经初始化。如果未初始化，表示系统不支持交换，因此无法从磁盘加载页面，此时应报告错误并退出。

**分配内存页**：
   - 调用`swap_in`函数，它负责从交换空间中读取数据到新分配的内存页中。`swap_in`需要三个参数：内存管理结构`mm`、虚拟地址`addr`和一个指向`Page`结构的指针`page`。`swap_in`函数会根据`pte`中的信息找到磁盘上的数据，并将其加载到`page`指向的内存页中。

**建立物理地址与虚拟地址的映射**：
   - 使用`page_insert`函数将新加载的物理页面映射到虚拟地址`addr`。这需要提供页目录`pgdir`、物理页面`page`、虚拟地址`addr`和页面权限`perm`。`page_insert`函数会更新页表，使得虚拟地址`addr`指向新加载的物理页面。

**设置页面可交换**：
   - 调用`swap_map_swappable`函数，将新加载的页面标记为可交换。这意味着在未来如果内存不足时，该页面可以被换出到磁盘。`swap_map_swappable`需要四个参数：内存管理结构`mm`、虚拟地址`addr`、物理页面`page`和一个标志（通常设置为1，表示页面可交换）。

**更新页面的虚拟地址**：
   - 将`page`结构中的`pra_vaddr`字段设置为虚拟地址`addr`，这样在将来换出该页面时，可以知道它对应的虚拟地址。

**错误处理**：
   - 如果在上述任何步骤中发生错误（例如，`swap_in`或`page_insert`失败），则打印错误信息并跳转到`failed`标签，返回错误码。


#### 2. **页目录项 (PDE) 和页表项 (PTE) 的组成部分对页替换算法的潜在用处**
在ucore操作系统中，页目录项（PDE）和页表项（PTE）的组成部分对于实现页替换算法具有以下潜在用处：

**有效位（V）**：表示该页表项或页目录项是否有效。在页替换算法中，无效的页表项可以被直接替换。

**读（R）、写（W）、执行（X）位**：这些位定义了页面的访问权限。在页替换时，可能会考虑页面的使用模式，例如，只读页面可能比读写页面更有可能被替换。

**用户/超级用户位（U）**：区分页面是用户模式可访问还是仅限内核模式。这有助于在页替换时保护内核空间。

**全局（G）位**：如果设置，表示该页面对所有地址空间都是全局可见的。这可以用于优化那些在多个进程间共享的页面。

**访问（A）位**：如果设置，表示该页面自从最后被清零以来至少被访问过一次。这对于最近最少使用（LRU）等页替换算法非常有用。

**脏（D）位**：如果设置，表示该页面自从最后被清零以来至少被写过一次。这有助于确定在页替换时是否需要将页面写回磁盘。

ucore 可以利用访问位和修改位信息设计更智能的页替换算法，例如LRU或改进型的Clock算法。

#### 3. **缺页服务例程访问内存导致页访问异常时硬件行为**
   - **保存上下文**：硬件会将当前处理器状态（如指令地址、错误代码）保存到寄存器或栈中。
   - **触发异常处理程序**：跳转到页访问异常对应的中断向量。
   - **设置错误代码**：硬件会在 `CR2` 寄存器中存储引发缺页的地址，在错误码中指示缺页的原因（如缺页、不允许写、用户访问内核页等）。
   - **切换权限**：如果从用户态访问，需要切换到内核态执行缺页处理例程。

#### 4.**Page数据结构与PDE/PTE的对应关系**

在 ucore 中，Page 结构体的全局变量(数组)用于管理物理内存中的每一个页面。每一个 page 结构体对应一个物理页。Page 结构体与页表中的页目录项(PDE)和页表项(PTE)有以下对应关系:

+ **Page 结构体**:
   + struct Page:表示一个物理页，包含物理页的相关信息，如引用计数、物理地址等
   + 全局变量:Page 结构体的全局变量是一个数组，每一项对应一个物理页。
+  **页表项(PTE)**:
   + 物理地址:PTE 中的物理地址字段指向一个物理页。这个物理页在 page 结构体的全局变量数组中有一个对应的 page 结构体
   + 映射关系:PTE 中的物理地址字段与 Page 结构体的物理地址字段相对应。
+ **页目录项(PDE)**:
   + 页表地址:PDE 中的地址字段指向一个页表。页表中的每一个 PTE 都指向一个物理页，这些物理页在 page 结构体的全局变量数组中有对应的 page 结构体。

   简单来说，PDE中的地址字段-->页表，页表中包含的PTE的物理地址字段-->Page结构体三者为逐步包含的关系
### 练习4：补充完成Clock页替换算法（需要编程）
通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。(提示:要输出curr_ptr的值才能通过make grade)

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 比较Clock页替换算法和FIFO算法的不同。

#### 初始化函数`_clock_init_mm(struct mm_struct *mm)`
在`_clock_init_mm`函数中：

- 初始化`pra_list_head`为空链表。
- `curr_ptr`初始化为链表头。
- `mm->sm_priv`初始化为链表头，用于后续的页面替换操作。

#### 函数`_clock_map_swappable(……)`
在`_clock_map_swappable`函数中：

- 将`page`对应的`entry`添加到`pra_list`的队尾。
- 将该页的`visited`标志初始化为 1。
```c
list_entry_t *head = mm->sm_priv;
// 注意这里！因为在后续的受害页选择函数中，`curr_ptr` 会被移动到受害页之后
list_add(list_prev(curr_ptr), entry);
// 将页面的 `visited` 标志置为 1，表示该页面已被访问
page->visited = 1;
```
#### 函数`_clock_swap_out_victim(……)`
在`_clock_swap_out_victim`函数中：

- 使用`curr_ptr`指针遍历整个`pra_list`。
- 如果遇到某个页面`visited`为 0，则该页为被换出的受害页。
- 如果某个页面`visited`为 1，则将其置为 0，继续查找。
```c
while (1) {
/*LAB3 EXERCISE 4: YOUR CODE*/
// 编写代码
// 遍历页面链表pra_list_head，查找最早未被访问的页面
// 获取当前页面对应的Page结构指针
// 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为
换出页面
// 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问
if(curr_ptr==head)
{
curr_ptr=curr_ptr->next;
}
// 获取当前页面对应的Page结构指针
victim=le2page(curr_ptr,pra_page_link);
// 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为
换出页面
if(victim->visited==0)
{
list_entry_t * t=curr_ptr;
curr_ptr=curr_ptr->next;
*ptr_page=victim;
cprintf("curr_ptr 0xffffffff%08x\n",(uintptr_t)t);
list_del(t);
break;
}
// 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问
victim->visited=0;
curr_ptr=curr_ptr->next;
}
```
#### 比较Clock页替换算法和FIFO算法的不同。

#### FIFO 页替换算法

#### 原理
FIFO（First-In-First-Out）算法是一种简单的页面置换算法，其核心思想是选择最早进入内存的页面作为被替换的页面。具体来说就是操作系统维护一个队列，队列中的页面按照进入内存的时间顺序排列，当需要替换页面时总是选择队列头部的页面进行替换。

#### 实现步骤
1. **初始化**：创建一个空的队列。
2. **页面进入**：每当一个新页面进入内存时，将其添加到队列的尾部。
3. **页面替换**：当需要替换页面时，从队列头部取出页面进行替换。

#### 优点
- **实现简单**：FIFO 算法的实现非常简单，只需要维护一个队列即可。
- **易于理解**：算法逻辑直观，容易理解和实现。

#### 缺点
- **性能较差**：FIFO 算法不考虑页面的访问频率和访问时间，可能会导致频繁访问的页面被替换出去，从而引发更多的缺页中断。
- **Belady's Anomaly**：FIFO 算法可能会出现 Belady's Anomaly，即增加内存中的页面数反而会导致缺页中断次数增加。

#### Clock 页替换算法

#### 原理
Clock 算法是一种改进的页面置换算法，它通过一个“时钟指针”来遍历页面，并使用一个“访问位”来标记页面是否被访问过。具体来说就是操作系统维护一个循环链表，链表中的每个节点代表一个页面，每个页面有一个访问位（visited）。当需要替换页面时，时钟指针从当前位置开始遍历，如果遇到一个访问位为 0 的页面，则选择该页面进行替换；如果访问位为 1，则将其置为 0 并继续遍历。

#### 实现步骤
1. **初始化**：创建一个空的循环链表，并初始化时钟指针。
2. **页面进入**：每当一个新页面进入内存时，将其添加到链表的末尾，并将其访问位置为 1。
3. **页面替换**：
   - 从当前时钟指针的位置开始遍历链表。
   - 如果遇到一个访问位为 0 的页面，则选择该页面进行替换。
   - 如果访问位为 1，则将其置为 0，并继续遍历。
   - 如果遍历完整个链表仍未找到访问位为 0 的页面，则重新从时钟指针的位置开始遍历。

#### 优点
- **性能较好**：Clock 算法考虑了页面的访问频率，避免了频繁访问的页面被替换出去，从而减少了缺页中断的次数。
- **避免 Belady's Anomaly**：Clock 算法不会出现 Belady's Anomaly，因为它考虑了页面的访问情况。

#### 缺点
- **实现复杂**：相对于 FIFO 算法，Clock 算法的实现稍微复杂一些，需要维护一个循环链表和时钟指针。
- **时间复杂度较高**：在最坏情况下，Clock 算法可能需要遍历整个链表一次，时间复杂度为 O(n)，而 FIFO 算法只需从队列头部取出一页，时间复杂度为 O(1)。

#### 总结

- **FIFO 页替换算法**：
  - **优点**：实现简单，易于理解。
  - **缺点**：性能较差，容易出现 Belady's Anomaly。

- **Clock 页替换算法**：
  - **优点**：性能较好，避免了 Belady's Anomaly。
  - **缺点**：实现稍微复杂，时间复杂度较高。

### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？
#### 一个大页的页表映射方式

#### 优点

- **实现简单**：
  - 只需要维护一个页表，不需要处理复杂的多级页表结构。
  - 简化了页表管理的代码，减少了出错的可能性。

- **访问速度快**：
  - 直接访问页表即可，无需多次查找多个级别的页表。
  - 减少了页表访问的延迟，提高了内存访问的效率。

- **占用内存少**：
  - 只有一个页表，占用的内存相对较少。
  - 特别是在虚拟内存较小的情况下，这种优势更为明显。

#### 缺点

- **物理内存需求大**：
  - 如果虚拟内存非常大，页表所需的物理内存也会相应增大。
  - 这可能导致内存资源的浪费，特别是在虚拟地址空间很大的系统中。

- **查找效率低下**：
  - 当页表中的页表项数量增多时，查找页表项的速度会变慢。
  - 这会影响内存访问的整体性能，尤其是在页表项非常多的情况下。

- **扩展性差**：
  - 随着系统规模的扩大，单一的大页表可能无法有效地管理大量的虚拟内存。
  - 在大型系统中，单一的大页表可能会成为性能瓶颈。

#### 分级页表映射方式

#### 优点

- **适用于大内存空间**：
  - 引入多级页表可以将页表项分散到多个页表中存储，适用于大内存空间的管理。
  - 有效减少了单个页表的大小，提高了查找效率。

- **灵活性高**：
  - 可以根据需要动态地分配和释放页表项，适应不同大小的虚拟内存。
  - 支持更复杂的内存管理策略，如按需分页和内存共享。

- **扩展性强**：
  - 能够有效地管理大规模的虚拟内存，适用于高性能计算和大型服务器系统。
  - 避免了单一大页表带来的性能瓶颈。

#### 缺点

- **实现复杂**：
  - 需要维护多个页表，增加了页表管理的复杂性。
  - 需要更多的代码来处理多级页表的查找和更新操作。

- **访问延迟增加**：
  - 访问内存时，需要访问多个表才能最终访问到物理地址，增加了访问延迟。
  - 这可能影响系统的整体性能，尤其是在频繁访问内存的情况下。

- **占用内存多**：
  - 需要维护多个页表，占用的内存相对较多。
  - 在页表项较少的情况下，使用分级页表可能会导致内存资源的浪费。

#### 总结

- **一个大页的页表映射方式**：
  - **优点**：实现简单、访问速度快、占用内存少。
  - **缺点**：物理内存需求大、查找效率低下、扩展性差。

- **分级页表映射方式**：
  - **优点**：适用于大内存空间、灵活性高、扩展性强。
  - **缺点**：实现复杂、访问延迟增加、占用内存多。

选择哪种页表映射方式取决于具体的应用场景和系统需求。对于小型系统或虚拟内存较小的情况，一个大页的页表映射方式可能是更好的选择。而对于大型系统或需要高效管理大量虚拟内存的情况，分级页表映射方式更为合适。

#### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）
challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。

请见lab3-lru.md文件。